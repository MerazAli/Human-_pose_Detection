# -*- coding: utf-8 -*-
"""human_pose.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ph2zkpECJPnnZxrQfevRzpJkvReHBv41
"""

# Installation of Mediapipe
!pip install mediapipe

import cv2
import time
import numpy as np

import matplotlib.pyplot as plt
import mediapipe as mp

"""# Initialize mediapipe pose class & stting up Pose function"""

# Initialize mediapipe pose class
mp_pose = mp.solutions.pose

  # Setting up pose Function


pose = mp_pose.Pose(static_image_mode=True,min_detection_confidence=0.3, model_complexity=2)

# Initialize mediapipe drawing class, useful for annotation
mp_drawing = mp.solutions.drawing_utils

# Now Read images
img=cv2.imread("/content/krata.jpg")

plt.figure(figsize=[10,10])
plt.title("Sampe image")
plt.axis("Off")
plt.imshow(img[:,:,::-1])
plt.show()
#cv2.imshow("Original",img)
#cv2.waitKey(0)
#cv2.destroyAllWindows()



"""**# Perform Pose Detection**

Now pass images to Pose detection ML pipeline using pose.process()
"""

# In opencv images aren BGR, but here are need into RGB
result=pose.process(cv2.cvtColor(img,cv2.COLOR_BGR2RGB))

#print(result)   #it return class of mediapipeline 
print(result.pose_landmarks)   # it return landmarks of pose

# Check  if any landmarks found
if result.pose_landmarks:
  for i in range(3):
    print(f"{mp_pose.PoseLandmark(i).name}:\n {result.pose_landmarks.landmark[mp_pose.PoseLandmark(i).value]}")



"""**#Retrieve height and width of image**"""

img.shape

img_height,img_width,_ = img.shape

# Check if any landmark found

if result.pose_landmarks:
  for i in range(2):
    print(f"{mp_pose.PoseLandmark(i).name}: ")
    print(f"{result.pose_landmarks.landmark[mp_pose.PoseLandmark(i).value].x*img_width}") 
    print(f"{result.pose_landmarks.landmark[mp_pose.PoseLandmark(i).value].y*img_height}")
    print(f"visibility:{result.pose_landmarks.landmark[mp_pose.PoseLandmark(i).value].visibility}\n")

"""**# Now Draw detected landmark om image usin draw_landmark()**"""

# make copy of original image 
img_copy = img.copy()

#  check if lamdmark found
if result.pose_landmarks:
  # Draw pose landmark on image
  mp_drawing.draw_landmarks(image=img_copy,landmark_list=result.pose_landmarks,connections=mp_pose.POSE_CONNECTIONS)


  # Specify size of image
  plt.figure(figsize=[10,10])
  plt.title("Outpit Image")
  plt.imshow(img_copy[:,:,::-1])
  plt.show()



"""# Visualize landmark in 3 Dimension"""

mp_drawing.plot_landmarks(result.pose_world_landmarks,mp_pose.POSE_CONNECTIONS)

"""**#Create a Pose Detection Function**"""

# Initialize mediapipe pose class
#mp_pose = mp.solutions.pose

  # Setting up pose Function


#pose = mp_pose.Pose(static_image_mode=True,min_detection_confidence=0.3, model_complexity=2)

def pose_detect(img,pose,display=True):
  img1=img.copy()
  imgRGB=cv2.cvtColor(img1,cv2.COLOR_BGR2RGB)
  result1=pose.process(imgRGB)
  height,width,_=imgRGB.shape
  
  # blank list
  landmarks=[]
  # Check if any landmark detected

  if result1.pose_landmarks:
    mp_drawing.draw_landmarks(image=img1,landmark_list=result1.pose_landmarks,connections=mp_pose.POSE_CONNECTIONS)
    # Iterate over detected landmark
    for i in result1.pose_landmarks.landmark:
      landmarks.append((int(i.x*width),int(i.y*height),(i.z*width)))


  if display:
    plt.figure(figsize=[10,10])
    plt.subplot(121)
    plt.imshow(img1[:,:,::-1])
    plt.title("Imgres")
    plt.show()

      #Also plot images  in 3D
    mp_drawing.plot_landmarks(result1.pose_world_landmarks,mp_pose.POSE_CONNECTIONS)
  else:
    return img1,landmarks

imgBGR=cv2.imread("/content/krata.jpg")
pose_detect(imgBGR,pose,display=True)

imgBGR=cv2.imread("/content/karate2.jpg")
pose_detect(imgBGR,pose,display=True)



"""Pose Detection On Real-Time Webcam Feed/Video"""

Python
# Setup Pose function for video.

import mediapipe as mp
import cv2
import numpy as np
import matplotlib.pyplot as plt

from time import time
# Initialize mediapipe pose class
mp_pose = mp.solutions.pose

pose_video = mp_pose.Pose(static_image_mode=False, min_detection_confidence=0.5, model_complexity=1)

# Initialize the VideoCapture object to read from the webcam.
video = cv2.VideoCapture(0)

# Initialize the VideoCapture object to read from a video stored in the disk.
#video = cv2.VideoCapture('media/running.mp4')


# Initialize a variable to store the time of the previous frame.
time1 = 0

# Iterate until the video is accessed successfully.
while video.isOpened():
    
    # Read a frame.
    ok, frame = video.read()
    
    # Check if frame is not read properly.
    if not ok:
        
        # Break the loop.
        break
    
    # Flip the frame horizontally for natural (selfie-view) visualization.
    frame = cv2.flip(frame, 1)
    
    # Get the width and height of the frame
    frame_height, frame_width, _ =  frame.shape
    
    # Resize the frame while keeping the aspect ratio.
    frame = cv2.resize(frame, (int(frame_width * (640 / frame_height)), 640))
    
    # Perform Pose landmark detection.
    frame, _ = detectPose(frame, pose_video, display=False)
    
    # Set the time for this frame to the current time.
    time2 = time()
    
    # Check if the difference between the previous and this frame time &gt; 0 to avoid division by zero.
    if (time2 - time1) &gt; 0:
    
        # Calculate the number of frames per second.
        frames_per_second = 1.0 / (time2 - time1)
        
        # Write the calculated number of frames per second on the frame. 
        cv2.putText(frame, 'FPS: {}'.format(int(frames_per_second)), (10, 30),cv2.FONT_HERSHEY_PLAIN, 2, (0, 255, 0), 3)
    
    # Update the previous frame time to this frame time.
    # As this frame will become previous frame in next iteration.
    time1 = time2
    
    # Display the frame.
    cv2.imshow('Pose Detection', frame)
    
    # Wait until a key is pressed.
    # Retreive the ASCII code of the key pressed
    k = cv2.waitKey(1) &amp; 0xFF
    
    # Check if 'ESC' is pressed.
    if(k == 27):
        
        # Break the loop.
        break

# Release the VideoCapture object.
video.release()

# Close the windows.
cv2.destroyAllWindows()

